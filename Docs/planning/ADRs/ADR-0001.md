# ADR-0001: Technology Stack Selection for Migration

**Status**: Proposed  
**Date**: December 31, 2025  
**Deciders**: Tech Lead, Engineering Manager, Product Owner  
**Consulted**: Development Team, Security Team, Operations Team

---

## Context

ContosoUniversity is currently built with ASP.NET Core 6 Razor Pages, Entity Framework Core 6, and SQL Server. We are migrating to a modern JavaScript stack to:

1. **Improve maintainability**: Separate frontend and backend for clearer separation of concerns
2. **Enable scalability**: Decouple UI from API for independent scaling
3. **Modernize technology**: Adopt contemporary web development practices
4. **Enhance developer experience**: Use TypeScript for type safety and better tooling
5. **Reduce infrastructure costs**: Use lightweight database (SQLite) for smaller datasets

We need to select:

- **Frontend framework**: React, Angular, Vue.js, or Svelte
- **Backend framework**: Express, Fastify, NestJS, or Koa
- **ORM**: Drizzle ORM, TypeORM, Sequelize, or Knex
- **Database**: SQLite, PostgreSQL, MySQL, or SQL Server
- **State management**: Redux Toolkit, Context API, Zustand, or Recoil
- **Authentication**: JWT, OAuth2, Session-based, or Auth0/Firebase
- **Testing frameworks**: Jest/Mocha, React Testing Library, Cypress/Playwright

---

## Decision Drivers

### Must-Have Requirements

1. **TypeScript support**: Type safety for both frontend and backend
2. **Active ecosystem**: Well-maintained libraries with strong community support
3. **Learning curve**: Reasonable for team with JavaScript experience
4. **Performance**: Comparable to or better than current .NET performance
5. **Tooling**: Excellent IDE support (VS Code), debugging, and testing
6. **Security**: Battle-tested libraries with good security track record
7. **Cost**: Open-source with no licensing fees

### Nice-to-Have Requirements

1. **Modern patterns**: Functional programming, hooks, async/await
2. **Database flexibility**: Easy migration from SQLite to PostgreSQL if needed
3. **API-first**: RESTful API design with OpenAPI/Swagger documentation
4. **Developer productivity**: Hot reload, fast builds, minimal boilerplate

---

## Options Considered

### Frontend Framework

#### Option 1: **React + TypeScript** ✅ Selected

**Pros**:

- ✅ Most popular (18M+ weekly npm downloads)
- ✅ Huge ecosystem (libraries, components, tooling)
- ✅ Excellent TypeScript support (built-in types)
- ✅ Component-based architecture (reusable, testable)
- ✅ Hooks API (modern, functional, less boilerplate)
- ✅ React DevTools (excellent debugging)
- ✅ Strong community (Stack Overflow, tutorials, examples)
- ✅ Virtual DOM (good performance)
- ✅ React Testing Library (comprehensive testing)
- ✅ Bootstrap integration (React-Bootstrap library)

**Cons**:

- ❌ Requires state management library (Redux, Context)
- ❌ JSX syntax learning curve (for team new to React)
- ❌ Frequent ecosystem changes (hooks replaced classes, etc.)

#### Option 2: Angular + TypeScript

**Pros**:

- ✅ Full-featured framework (routing, forms, HTTP built-in)
- ✅ TypeScript-first (designed for TypeScript)
- ✅ Opinionated structure (less decision fatigue)
- ✅ RxJS for reactive programming

**Cons**:

- ❌ Steeper learning curve (decorators, DI, RxJS)
- ❌ Less flexible (opinionated structure)
- ❌ Heavier bundle size
- ❌ Less popular than React (3M weekly downloads)

**Decision**: ❌ Rejected - steeper learning curve, less ecosystem

#### Option 3: Vue.js + TypeScript

**Pros**:

- ✅ Easy to learn (template-based syntax)
- ✅ Good TypeScript support (Vue 3)
- ✅ Smaller bundle size
- ✅ Good documentation

**Cons**:

- ❌ Smaller ecosystem than React
- ❌ Less common in enterprise (harder to hire)
- ❌ Composition API requires Vue 3 (recent change)

**Decision**: ❌ Rejected - smaller ecosystem, less team familiarity

---

### Backend Framework

#### Option 1: **Express + TypeScript** ✅ Selected

**Pros**:

- ✅ Most popular (20M+ weekly npm downloads)
- ✅ Minimal, unopinionated (flexible architecture)
- ✅ Huge middleware ecosystem (authentication, validation, logging)
- ✅ Excellent TypeScript support (@types/express)
- ✅ Well-documented (10+ years of content)
- ✅ Easy to learn (straightforward API)
- ✅ Battle-tested (used by Netflix, PayPal, Uber)

**Cons**:

- ❌ Less structure (requires architectural decisions)
- ❌ Manual configuration (DI, validation, etc.)
- ❌ Slower than Fastify (for high-throughput scenarios)

#### Option 2: NestJS + TypeScript

**Pros**:

- ✅ TypeScript-first (Angular-inspired architecture)
- ✅ Opinionated structure (less decision fatigue)
- ✅ Built-in DI, validation, guards
- ✅ Excellent for large teams
- ✅ Microservices support

**Cons**:

- ❌ Steeper learning curve (decorators, DI, modules)
- ❌ More boilerplate (for simple CRUD apps)
- ❌ Less flexible (opinionated structure)
- ❌ Overkill for small app like ContosoUniversity

**Decision**: ❌ Rejected - overkill for this project size

#### Option 3: Fastify + TypeScript

**Pros**:

- ✅ Fastest Node.js framework (benchmarks)
- ✅ Schema-based validation (JSON Schema)
- ✅ Good TypeScript support

**Cons**:

- ❌ Smaller ecosystem than Express
- ❌ Less community content
- ❌ Performance not critical for this use case

**Decision**: ❌ Rejected - Express ecosystem more valuable

---

### ORM (Object-Relational Mapping)

#### Option 1: **Drizzle ORM** ✅ Selected

**Pros**:

- ✅ TypeScript-first, type-safe SQL query builder
- ✅ Code-first schema in TypeScript (tables and columns)
- ✅ Excellent developer experience (minimal boilerplate)
- ✅ Type-safe queries (compile-time errors)
- ✅ Migrations via drizzle-kit (generate/migrate)
- ✅ Supports SQLite and PostgreSQL (easy to switch)
- ✅ Modern lightweight design

**Cons**:

- ❌ Smaller ecosystem than Prisma (but growing rapidly)
- ❌ Requires explicit joins (no auto-include)
- ❌ SQL Server not targeted (not needed for this project)

#### Option 2: TypeORM

**Pros**:

- ✅ Mature (7+ years)
- ✅ Decorator-based (similar to EF Core)
- ✅ Active Record or Data Mapper patterns
- ✅ Query Builder (flexible)

**Cons**:

- ❌ TypeScript support good but not excellent (manual type maintenance)
- ❌ Migrations less polished than Prisma
- ❌ Less active development (fewer updates)
- ❌ More boilerplate (decorators, repositories)

**Decision**: ❌ Rejected - Drizzle ORM DX superior

#### Option 3: Sequelize

**Pros**:

- ✅ Very mature (oldest, most stable)
- ✅ Large ecosystem

**Cons**:

- ❌ Poor TypeScript support (legacy, JavaScript-first)
- ❌ Not recommended for new TypeScript projects

**Decision**: ❌ Rejected - poor TypeScript support

---

### Database

#### Option 1: **SQLite** ✅ Selected

**Pros**:

- ✅ Zero configuration (file-based database)
- ✅ Lightweight (no separate server process)
- ✅ Perfect for small-to-medium datasets (<10GB)
- ✅ ACID compliant (transactions, foreign keys)
- ✅ WAL mode for better concurrency
- ✅ Low infrastructure cost (no database server)
- ✅ Easy backups (copy file)
- ✅ Drizzle ORM supports SQLite well

**Cons**:

- ❌ Limited concurrency (single writer)
- ❌ No distributed database support
- ❌ Less suitable for high-write workloads
- ❌ Maximum database size 281 TB (acceptable for this use case)

**Migration Path**: If SQLite insufficient, migrate to PostgreSQL (Drizzle ORM supports both, minimal code changes)

#### Option 2: PostgreSQL

**Pros**:

- ✅ Excellent concurrency (MVCC)
- ✅ Advanced features (JSONB, full-text search, GIS)
- ✅ Highly scalable
- ✅ Open-source

**Cons**:

- ❌ Requires database server (infrastructure cost)
- ❌ More complex configuration
- ❌ Overkill for current dataset size

**Decision**: ❌ Use SQLite initially, migrate to PostgreSQL if needed

#### Option 3: SQL Server (keep existing)

**Pros**:

- ✅ No data migration required
- ✅ Team familiar with SQL Server

**Cons**:

- ❌ Licensing cost (unless using Express edition)
- ❌ Heavier infrastructure
- ❌ Less alignment with JavaScript ecosystem
- ❌ SQL Server support not targeted for Drizzle ORM

**Decision**: ❌ Rejected - migrate to SQLite for cost and simplicity

---

### State Management (Frontend)

#### Option 1: **Redux Toolkit** ✅ Selected

**Pros**:

- ✅ Industry standard (predictable state management)
- ✅ Redux Toolkit reduces boilerplate (createSlice, createAsyncThunk)
- ✅ Excellent DevTools (time-travel debugging)
- ✅ Well-documented patterns (Redux Style Guide)
- ✅ Middleware support (thunks, sagas)
- ✅ RTK Query (built-in data fetching)

**Cons**:

- ❌ Learning curve (actions, reducers, selectors)
- ❌ More boilerplate than Context API (but Redux Toolkit improves this)
- ❌ Might be overkill for simple apps

**Decision**: ✅ Selected - complexity justified for multi-module app with shared state

#### Option 2: Context API

**Pros**:

- ✅ Built into React (no extra dependency)
- ✅ Simple for small apps
- ✅ Easy to learn

**Cons**:

- ❌ No DevTools (harder debugging)
- ❌ Performance issues with frequent updates (re-renders)
- ❌ No built-in async action handling
- ❌ Less structure (easy to misuse)

**Decision**: ❌ Rejected - insufficient for multi-module app

#### Option 3: Zustand

**Pros**:

- ✅ Minimal boilerplate (simpler than Redux)
- ✅ Good performance
- ✅ Easy to learn

**Cons**:

- ❌ Smaller ecosystem
- ❌ Less tooling (no DevTools)
- ❌ Less common (harder to find examples)

**Decision**: ❌ Rejected - Redux Toolkit more battle-tested

---

### Authentication

#### Option 1: **JWT (jsonwebtoken)** ✅ Selected

**Pros**:

- ✅ Stateless (no server-side session storage)
- ✅ Scalable (works with load balancers, microservices)
- ✅ Standard (RFC 7519)
- ✅ Flexible (can include custom claims)
- ✅ Works with httpOnly cookies (secure)

**Cons**:

- ❌ Cannot revoke tokens (without database check)
- ❌ Requires careful implementation (XSS, CSRF protection)
- ❌ Token size larger than session ID

**Mitigation**: Use short-lived access tokens (15 min) + long-lived refresh tokens (7 days) + token revocation list in database

#### Option 2: OAuth2/OpenID Connect (e.g., Auth0, Firebase)

**Pros**:

- ✅ Fully managed (less code to maintain)
- ✅ Social login (Google, Facebook)
- ✅ Enterprise features (SSO, MFA)

**Cons**:

- ❌ Third-party dependency (vendor lock-in)
- ❌ Cost (for production usage)
- ❌ Overkill for simple university app
- ❌ Current .NET app has no auth (not required initially)

**Decision**: ❌ Rejected - JWT sufficient for this use case

#### Option 3: Session-based (express-session)

**Pros**:

- ✅ Simple (server-side session storage)
- ✅ Easy to revoke sessions

**Cons**:

- ❌ Stateful (requires session store: Redis, database)
- ❌ Less scalable (sticky sessions or shared session store)
- ❌ Not ideal for SPA (JWT better for API-first)

**Decision**: ❌ Rejected - JWT more modern, stateless

---

### Testing Frameworks

#### Backend Testing: **Mocha + Chai + Supertest** ✅ Selected

**Pros**:

- ✅ Mocha: Flexible, popular, BDD-style
- ✅ Chai: Expressive assertions (expect, should, assert)
- ✅ Supertest: HTTP testing (integration tests)
- ✅ Well-documented

**Cons**:

- ❌ More configuration than Jest (need separate assertion library)

**Alternative**: Jest (also excellent, but Mocha/Chai more traditional for Node.js)

**Decision**: ✅ Mocha + Chai for backend (per user requirement)

#### Frontend Testing: **Jest + React Testing Library** ✅ Selected

**Pros**:

- ✅ Jest: Most popular (built-in assertion, mocking, coverage)
- ✅ Zero config with Create React App
- ✅ Fast (parallel execution)
- ✅ React Testing Library: Best practices (test behavior, not implementation)

**Cons**:

- ❌ None significant

**Decision**: ✅ Jest + React Testing Library (per user requirement)

#### E2E Testing: **Playwright** ✅ Selected

**Pros**:

- ✅ Modern (developed by Microsoft)
- ✅ Cross-browser (Chrome, Firefox, Safari, Edge)
- ✅ Fast (parallel execution)
- ✅ Auto-wait (less flakiness)
- ✅ TypeScript support
- ✅ Excellent documentation

**Alternative**: Cypress (also excellent, slightly more popular)

**Decision**: ✅ Playwright (slight edge in performance and TypeScript support)

---

## Decision

We will use the following technology stack:

### Frontend

- **Framework**: React 18.x + TypeScript
- **State Management**: Redux Toolkit 2.x
- **UI Library**: Bootstrap 5.3.x (same as current)
- **HTTP Client**: Axios 1.x
- **Routing**: React Router v6
- **Form Validation**: Yup
- **Testing**: Jest + React Testing Library

### Backend

- **Framework**: Express 4.x + TypeScript
- **ORM**: Drizzle ORM
- **Database**: SQLite 3 (with migration path to PostgreSQL)
- **Authentication**: JWT (jsonwebtoken) with httpOnly cookies
- **Validation**: Zod (TypeScript-first schema validation)
- **Logging**: Pino (structured logging)
- **Testing**: Mocha + Chai + Supertest

### E2E Testing

- **Framework**: Playwright

### Tooling

- **Package Manager**: npm (standard, no need for pnpm/yarn)
- **Build Tool**: TypeScript Compiler (tsc) for backend, Vite or Create React App for frontend
- **Linting**: ESLint + Prettier
- **Version Control**: Git (GitHub)

---

## Consequences

### Positive

1. **Type Safety**: TypeScript across frontend and backend reduces runtime errors
2. **Developer Experience**: Drizzle ORM, React, and Redux Toolkit have excellent DX
3. **Ecosystem**: React and Express have massive ecosystems (libraries, tutorials, hiring)
4. **Cost**: SQLite eliminates database server costs
5. **Flexibility**: Drizzle ORM supports multiple databases (easy to migrate from SQLite to PostgreSQL)
6. **Modern**: Stack aligns with 2024 best practices (hooks, async/await, schema-first)
7. **Testability**: Comprehensive testing tools (Jest, Mocha, Playwright)

### Negative

1. **Learning Curve**: Team needs to learn React, Redux Toolkit, Drizzle ORM (mitigated by training)
2. **SQLite Limitations**: Single-writer limitation (mitigated by WAL mode, acceptable for dataset size)
3. **State Management Complexity**: Redux Toolkit adds complexity (but necessary for multi-module app)
4. **JWT Security**: Requires careful implementation (mitigated by security audit, best practices)
5. **Data Migration**: SQL Server → SQLite migration required (mitigated by validation scripts)

### Neutral

1. **Two Languages**: TypeScript for both frontend and backend (unified language)
2. **Documentation Effort**: New stack requires updated documentation (addressed in planning phase)

---

## Alternatives Considered and Rejected

| Alternative    | Reason for Rejection                              |
| -------------- | ------------------------------------------------- |
| Angular        | Steeper learning curve, less flexible             |
| Vue.js         | Smaller ecosystem, less team familiarity          |
| NestJS         | Overkill for project size                         |
| Fastify        | Express ecosystem more valuable                   |
| TypeORM        | Drizzle ORM DX superior                           |
| PostgreSQL     | SQLite sufficient for current dataset, lower cost |
| Context API    | Insufficient for multi-module app                 |
| Auth0/Firebase | Overkill, vendor lock-in                          |
| Cypress        | Playwright slightly better TypeScript support     |

---

## Validation

This decision will be validated through:

1. **Proof of Concept**: Implement Students module with selected stack (Phase 1-2)
2. **Performance Benchmark**: Compare React/Node performance to .NET baseline (Phase 6)
3. **Team Feedback**: Collect developer feedback after Phase 2 (Backend Planning)
4. **Security Audit**: Validate JWT implementation (Phase 4)
5. **Stakeholder Review**: Present architecture diagrams for approval (Phase 1)

---

## Related ADRs

- ADR-0002: Authentication Strategy (JWT + httpOnly cookies)
- ADR-0003: Testing Framework Selection (Jest/Mocha/Playwright)
- ADR-0004: Database Migration Strategy (SQL Server → SQLite)

---

**Status**: Proposed (awaiting team approval)  
**Date Created**: December 31, 2025  
**Last Updated**: December 31, 2025  
**Approvers**: Tech Lead, Engineering Manager, Product Owner
